from pathlib import Pathfrom typing import Unionimport torch.nn as nnimport yaml_activations = {    "none": nn.Identity(),    "identity": nn.Identity(),    "tanh": nn.Tanh(),    "sigmoid": nn.Sigmoid(),    "softplus": nn.Softplus(),    "elu": nn.ELU(),    "relu": nn.ReLU(),    "leakyrelu": nn.LeakyReLU(),}def get_activation_fn(name):    if name is None:        return _activations["none"]    name = name.lower()    return _activations[name]class BaseModel(nn.Module):    _models = dict()    def __init_subclass__(cls, name=None, **kwargs):        super().__init_subclass__(**kwargs)        if name is not None:            BaseModel._models[name.lower()] = cls            cls._name = name        else:            BaseModel._models[cls.__name__.lower()] = cls            cls._name = cls.__name__def available_models():    return list(BaseModel._models.keys())def _get_model(model_config: dict, data_channels: int):    for key, value in model_config.items():        if key.endswith("activation"):            model_config[key] = get_activation_fn(value)    model_config["data_channels"] = data_channels    # load model    name = model_config.pop("name").lower()    try:        return BaseModel._models[name](**model_config)    except KeyError:        raise ValueError(f"Got model name={name}, expected one of {available_models()}.")def get_model(model_config_path: Union[Path, str], data_channels: int):    with open(model_config_path, "r") as f:        config = yaml.safe_load(f)    model_config = config["model"]    return _get_model(model_config, data_channels)